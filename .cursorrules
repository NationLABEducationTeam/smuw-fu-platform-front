# AWS Lambda 함수 정보

# 전체 인프라 구성 및 통신 방식

## 시스템 아키텍처
1. **프론트엔드**: Next.js 웹 애플리케이션
   - 사용자 인터페이스 제공
   - WebSocket을 통한 실시간 통신
   - 채팅 기록 관리 (로컬 스토리지 활용)
   - AWS Cognito를 통한 사용자 인증

2. **백엔드**: AWS 서비스
   - API Gateway (WebSocket API)
   - Lambda 함수 (4개)
   - DynamoDB (2개 테이블)
   - Amazon Bedrock (Claude 3.5 Sonnet)
   - AWS Cognito (사용자 인증)

## 통신 흐름
1. **연결 설정**:
   - 사용자가 채팅 페이지에 접속하면 WebSocket 연결 시작
   - 프론트엔드에서 JWT 토큰을 쿼리 파라미터로 포함하여 WebSocket API 엔드포인트로 연결 요청
   - API Gateway가 `$connect` 라우트를 통해 `connectHandler` Lambda 함수 호출
   - `connectHandler`가 JWT 토큰을 검증하고 연결 ID를 DynamoDB의 `WebSocketConnections` 테이블에 저장

2. **메시지 전송**:
   - 사용자가 메시지 입력 후 전송
   - 프론트엔드에서 WebSocket을 통해 `chatRequest` 타입의 메시지 전송
   - API Gateway가 `chatRequest` 라우트를 통해 `chatrequestHandler` Lambda 함수 호출

3. **AI 응답 생성**:
   - `chatrequestHandler`가 Amazon Bedrock API 호출
   - Claude 3.5 Sonnet 모델을 사용하여 응답 생성 (스트리밍 방식)
   - 응답 청크가 생성될 때마다 WebSocket을 통해 프론트엔드로 전송
   - 응답 완료 시 전체 응답을 DynamoDB의 `ChatHistory` 테이블에 저장

4. **연결 종료**:
   - 사용자가 페이지를 떠나거나 연결 해제 시 WebSocket 연결 종료
   - API Gateway가 `$disconnect` 라우트를 통해 `disconnectHandler` Lambda 함수 호출
   - `disconnectHandler`가 DynamoDB에서 해당 연결 ID 제거

## 프론트엔드 구현
1. **WebSocket 연결 관리**:
   - `utils/chat.js`의 `ChatService` 클래스를 통해 WebSocket 연결 관리
   - 연결 상태에 따른 UI 업데이트
   - 주기적인 Ping 메시지 전송으로 연결 유지
   - 인증 토큰을 WebSocket URL에 포함하여 보안 강화

2. **채팅 인터페이스**:
   - `components/chatbot/chatbot-page.tsx`에서 채팅 UI 구현
   - 메시지 입력, 전송, 표시 기능
   - 스트리밍 응답 실시간 표시
   - 대화 기록 저장 및 불러오기

3. **모델 선택**:
   - `types/bedrock.ts`에서 사용 가능한 모델 정의
   - 현재는 Claude 3.5 Sonnet만 사용

4. **사용자 인증**:
   - `utils/auth.ts`에서 AWS Cognito 인증 관리
   - 회원가입, 로그인, 로그아웃 기능 구현
   - JWT 토큰 관리 및 API 요청에 인증 정보 포함

## WebSocket API 엔드포인트
- URL: wss://dzamj9uv1g.execute-api.ap-northeast-2.amazonaws.com/production

## connectHandler
```javascript
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand } from '@aws-sdk/lib-dynamodb';
import { CognitoJwtVerifier } from 'aws-jwt-verify';

const client = new DynamoDBClient({});
const dynamoDB = DynamoDBDocumentClient.from(client);

// Cognito JWT 검증기 설정
const verifier = CognitoJwtVerifier.create({
  userPoolId: 'ap-northeast-2_6vGiuXQDD',
  tokenUse: 'id',
  clientId: 'YOUR_CLIENT_ID' // Cognito 앱 클라이언트 ID
});

export const handler = async (event) => {
  const connectionId = event.requestContext.connectionId;
  
  try {
    // 쿼리 파라미터에서 토큰 추출
    const queryParams = event.queryStringParameters || {};
    const token = queryParams.token;
    
    // 토큰이 없는 경우 연결 거부 (선택적)
    if (!token) {
      console.log('토큰이 제공되지 않았습니다.');
      // 개발 중에는 토큰 없이도 연결 허용 (프로덕션에서는 제거)
      // return { statusCode: 401, body: 'Unauthorized: No token provided' };
    } else {
      try {
        // 토큰 검증
        const payload = await verifier.verify(token);
        console.log('토큰 검증 성공:', payload.sub);
        
        // 사용자 ID를 연결 정보와 함께 저장
        await dynamoDB.send(new PutCommand({
          TableName: 'WebSocketConnections',
          Item: {
            connectionId: connectionId,
            userId: payload.sub,
            timestamp: new Date().toISOString()
          }
        }));
      } catch (verifyError) {
        console.error('토큰 검증 실패:', verifyError);
        // 개발 중에는 토큰 검증 실패해도 연결 허용 (프로덕션에서는 제거)
        // return { statusCode: 401, body: 'Unauthorized: Invalid token' };
        
        // 토큰 없이 연결 정보 저장
        await dynamoDB.send(new PutCommand({
          TableName: 'WebSocketConnections',
          Item: {
            connectionId: connectionId,
            timestamp: new Date().toISOString()
          }
        }));
      }
    }
    
    return { statusCode: 200, body: 'Connected' };
  } catch (error) {
    console.error('Error connecting:', error);
    return { statusCode: 500, body: 'Failed to connect: ' + JSON.stringify(error) };
  }
};
```

## disconnectHandler
```javascript
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, DeleteCommand } from '@aws-sdk/lib-dynamodb';

const client = new DynamoDBClient({});
const dynamoDB = DynamoDBDocumentClient.from(client);

export const handler = async (event) => {
  const connectionId = event.requestContext.connectionId;
  
  try {
    await dynamoDB.send(new DeleteCommand({
      TableName: 'WebSocketConnections',
      Key: {
        connectionId: connectionId
      }
    }));
    
    return { statusCode: 200, body: 'Disconnected' };
  } catch (error) {
    console.error('Error disconnecting:', error);
    return { statusCode: 500, body: 'Failed to disconnect: ' + JSON.stringify(error) };
  }
};
```

## defaultHandler
```javascript
export const handler = async (event) => {
  return {
    statusCode: 200,
    body: JSON.stringify({ message: 'Unrecognized action' })
  };
};
```

## chatrequestHandler
```javascript
import { ApiGatewayManagementApiClient, PostToConnectionCommand } from '@aws-sdk/client-apigatewaymanagementapi';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand, GetCommand } from '@aws-sdk/lib-dynamodb';
import { BedrockRuntimeClient, InvokeModelWithResponseStreamCommand } from '@aws-sdk/client-bedrock-runtime';
import { QueryCommand } from '@aws-sdk/lib-dynamodb';

// DynamoDB 클라이언트 초기화
const dbClient = new DynamoDBClient({
  region: 'ap-northeast-2'
});
const dynamoDB = DynamoDBDocumentClient.from(dbClient);

// Bedrock 클라이언트 초기화
const bedrock = new BedrockRuntimeClient({
  region: 'ap-northeast-2'
});

// API Gateway Management API 클라이언트 초기화
const createApiGatewayManagementApi = (event) => {
  const endpoint = `https://${event.requestContext.domainName}/${event.requestContext.stage}`;
  return new ApiGatewayManagementApiClient({
    endpoint,
    region: 'ap-northeast-2'
  });
};

// 메시지 전송 함수
const sendMessageToClient = async (apiGateway, connectionId, message) => {
  try {
    await apiGateway.send(new PostToConnectionCommand({
      ConnectionId: connectionId,
      Data: Buffer.from(JSON.stringify(message))
    }));
  } catch (error) {
    console.error('Error sending message to client:', error);
    if (error.statusCode === 410) {
      console.log(`Connection ${connectionId} is stale`);
    }
  }
};

// 연결 정보 조회 함수
async function getConnectionInfo(connectionId) {
  try {
    const { Item } = await dynamoDB.send(new GetCommand({
      TableName: 'WebSocketConnections',
      Key: {
        connectionId: connectionId
      }
    }));
    
    return Item || { connectionId };
  } catch (error) {
    console.error('Error fetching connection info:', error);
    return { connectionId };
  }
}

// 대화 이력 조회 함수
async function getChatHistory(sessionId, userId) {
  try {
    // 사용자 ID가 있는 경우 해당 사용자의 대화 이력만 조회
    const params = {
      TableName: 'ChatHistory',
      KeyConditionExpression: 'sessionId = :sessionId',
      ExpressionAttributeValues: {
        ':sessionId': sessionId
      },
      ScanIndexForward: true // 시간순 정렬
    };
    
    if (userId) {
      params.FilterExpression = 'userId = :userId';
      params.ExpressionAttributeValues[':userId'] = userId;
    }
    
    const { Items } = await dynamoDB.send(new QueryCommand(params));
    
    return Items || [];
  } catch (error) {
    console.error('Error fetching chat history:', error);
    return [];
  }
}

// 대화 컨텍스트를 포함한 모델 페이로드 생성 함수
async function getModelPayloadWithContext(modelId, message, sessionId, userId) {
  // 이전 대화 내용 조회
  const chatHistory = await getChatHistory(sessionId, userId);
  
  // 메시지 배열 구성
  const messages = [];
  
  // 이전 대화 내용을 메시지 배열에 추가
  for (const item of chatHistory) {
    messages.push({
      role: "user",
      content: [{ type: "text", text: item.userMessage }]
    });
    
    messages.push({
      role: "assistant",
      content: [{ type: "text", text: item.aiResponse }]
    });
  }
  
  // 현재 사용자 메시지 추가
  messages.push({
    role: "user",
    content: [{ type: "text", text: message }]
  });
  
  // Claude 3.5 Sonnet 모델 (APAC 리전)
  if (modelId.includes('anthropic.claude-3-5-sonnet')) {
    return {
      anthropic_version: "bedrock-2023-05-31",
      max_tokens: 1000,
      temperature: 0.7,
      top_p: 0.9,
      messages: messages,
    };
  }
  
  // 다른 모델 처리...
  throw new Error('Unsupported model');
}

// 스트리밍 응답 처리 함수
async function handleStreamingResponse(apiGateway, connectionId, modelId, sessionId, stream, message, userId) {
  let fullResponse = '';
  
  try {
    for await (const chunk of stream) {
      if (chunk.chunk?.bytes) {
        const decoder = new TextDecoder('utf-8');
        const decodedChunk = decoder.decode(chunk.chunk.bytes);
        
        try {
          const parsedChunk = JSON.parse(decodedChunk);
          let textChunk = '';
          
          // 모델별 응답 형식에 따라 텍스트 추출
          if (modelId.includes('anthropic.claude-3-5-sonnet')) {
            if (parsedChunk.type === 'content_block_delta' && 
                parsedChunk.delta?.type === 'text_delta') {
              textChunk = parsedChunk.delta.text || '';
            }
          }
          
          if (textChunk) {
            fullResponse += textChunk;
            
            // 클라이언트에 스트리밍 청크 전송
            await sendMessageToClient(apiGateway, connectionId, {
              type: 'chatStream',
              data: {
                message: textChunk,
                modelId,
                sessionId,
                isComplete: false
              }
            });
          }
        } catch (parseError) {
          console.error('Error parsing chunk:', parseError);
        }
      }
    }
    
    // 스트리밍 완료 메시지 전송
    await sendMessageToClient(apiGateway, connectionId, {
      type: 'chatStreamEnd',
      data: {
        message: fullResponse,
        modelId,
        sessionId,
        isComplete: true
      }
    });
    
    // 대화 이력 저장
    await saveChatHistory(sessionId, message, fullResponse, modelId, userId);
    
    return fullResponse;
  } catch (error) {
    console.error('Error in streaming:', error);
    throw error;
  }
}

// 대화 이력 저장 함수
async function saveChatHistory(sessionId, userMessage, aiResponse, modelId, userId) {
  const timestamp = new Date().toISOString();
  
  try {
    const item = {
      sessionId: sessionId,
      timestamp: timestamp,
      userMessage: userMessage,
      aiResponse: aiResponse,
      modelId: modelId
    };
    
    // 사용자 ID가 있는 경우 추가
    if (userId) {
      item.userId = userId;
    }
    
    await dynamoDB.send(new PutCommand({
      TableName: 'ChatHistory',
      Item: item
    }));
  } catch (error) {
    console.error('Error saving chat history:', error);
  }
}

export const handler = async (event) => {
  const connectionId = event.requestContext.connectionId;
  const apiGateway = createApiGatewayManagementApi(event);
  
  try {
    // 연결 정보 조회 (사용자 ID 포함)
    const connectionInfo = await getConnectionInfo(connectionId);
    const userId = connectionInfo.userId;
    
    const body = JSON.parse(event.body);
    const { type, data } = body;
    
    if (type === 'chatRequest') {
      const { message, modelId, sessionId } = data;
      
      console.log(`Processing request: ${JSON.stringify({ message, modelId, sessionId, userId })}`);
      
      // 스트리밍 시작 알림
      await sendMessageToClient(apiGateway, connectionId, {
        type: 'chatStream',
        data: {
          message: '',
          modelId,
          sessionId,
          isComplete: false
        }
      });
      
      // 대화 컨텍스트를 포함한 Bedrock 모델 호출 (스트리밍)
      const payload = await getModelPayloadWithContext(modelId, message, sessionId, userId);
      console.log(`Bedrock request payload: ${JSON.stringify(payload)}`);
      
      const command = new InvokeModelWithResponseStreamCommand({
        modelId: modelId,
        body: JSON.stringify(payload),
        contentType: "application/json",
        accept: "application/json",
      });

      const response = await bedrock.send(command);
      
      // 스트리밍 응답 처리
      await handleStreamingResponse(apiGateway, connectionId, modelId, sessionId, response.body, message, userId);
    }
    
    return { statusCode: 200, body: 'Message processed' };
  } catch (error) {
    console.error('Error:', error);
    
    // 에러 응답 전송
    try {
      await sendMessageToClient(apiGateway, connectionId, {
        type: 'error',
        data: {
          code: 'PROCESSING_ERROR',
          message: error.message || '오류가 발생했습니다.'
        }
      });
    } catch (postError) {
      console.error('Error sending error message:', postError);
    }
    
    return { statusCode: 500, body: JSON.stringify({ error: error.message }) };
  }
};

## 모델 ID 정보
- 현재 사용 중인 모델: Claude 3.5 Sonnet (APAC 리전)
- 모델 ID: `apac.anthropic.claude-3-5-sonnet-20240620-v1:0`

## DynamoDB 테이블
1. WebSocketConnections
   - 용도: WebSocket 연결 정보 저장
   - 파티션 키: connectionId (문자열)
   - 속성: timestamp (문자열), userId (문자열, 선택적)

2. ChatHistory
   - 용도: 채팅 이력 저장
   - 파티션 키: sessionId (문자열)
   - 정렬 키: timestamp (문자열)
   - 속성: userMessage (문자열), aiResponse (문자열), modelId (문자열), userId (문자열, 선택적)

## AWS Cognito 설정
- User Pool ID: ap-northeast-2_6vGiuXQDD
- 인증 흐름: 사용자 이름/비밀번호 인증
- 토큰 관리: JWT 토큰 (ID 토큰, 액세스 토큰) 